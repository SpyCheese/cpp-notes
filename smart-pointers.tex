\section{Умные указатели}

Рассмотрим следующий код:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
container* create_container()
{
    container* c = new container();
    fill(*c);
    return c;
}
\end{minted}

В приведенном коде, при возникновении исключения в функции fill, это исключение пролетит наружу функции create\_container. Однако выделенный с помощью new контейнер c не будет освобожден. Возможным способом исправления этой ошибки является использование try…catch блока:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
container* create_container()
{
    container* c = new container();
    try
    {
        fill(*c);
    }
    catch(...)
    {
        delete c;
        throw;
    }
    return c;
}
\end{minted}

Такой способ применим если лишь к простейшим функциям. При начилии нескольких объектов, которые требуется удалить или в присутствии сложного control-flow такое использование try...catch становится непрактичным.

Для решения этой проблемы в C++11 появились классы умных указателей (\mintinline{c++}{std::unique_ptr}, \mintinline{c++}{std::shared_ptr} и \mintinline{c++}{std::weak_ptr}). Эти классы являются RAII-обертками над обычными указателями, которые в своём деструкторе делают \mintinline{c++}{delete} тому объекту, на который они ссылаются. При использовании \mintinline{c++}{std::unique_ptr} приведенный выше (корректный) код может быть записан следующим образом:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
std::unique_ptr<container> create_container()
{
    std::unique_ptr<container> c(new container());
    fill(*c);
    return c;
}
\end{minted}

\subsection{unique\_ptr}
Самым простым умным указателем является \mintinline{c++}{std::unique_ptr}.
Внутри себя \mintinline{c++}{std::unique_ptr} хранит один указатель \mintinline{c++}{T* ptr} и делает ему \mintinline{c++}{delete} в дескрукторе.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template<class T>
class unique_ptr
{
private:
    T* ptr;
public:
    unique_ptr()
        : ptr(nullptr)
    {}

    unique_ptr(T* ptr)
        : ptr(ptr)
    {}

    ~unique_ptr()
    {
        delete ptr;
    }
    ...
}
\end{minted}

\mintinline{c++}{std::unique_ptr} имеет операторы \mintinline{c++}{*} и \mintinline{c++}{->}, поэтому им можно пользоваться как обычным указателем:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T& operator*() const { return *ptr; }
T* operator->() const noexcept { return ptr; }
\end{minted}

\mintinline{c++}{std::unique_ptr} имеет следующие функции:

\mintinline{c++}{get()} --- возвращает ptr, хранящийся внутри. \mintinline{c++}{get()} может использоваться если необходимо передать в некоторую функцию сырой указатель на объект, а имеется \mintinline{c++}{unique_ptr} на него.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T* get() const { return ptr; }
\end{minted}

\mintinline{c++}{release()} --- зануляет ptr, хранящийся внутри, а старое значение возвращает наружу. \mintinline{c++}{release()} может использоваться если необходимо передать в некоторую функцию сырой указатель на объект и известно, что эта функция самостоятельно удалит переданный объект.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T* release()
{
    T* tmp = ptr;
    ptr = nullptr;
    return tmp;
}
\end{minted}

\mintinline{c++}{reset(p)} - заменяет ptr, хранящийся внутри, на p, и делает \mintinline{c++}{delete} старому ptr.
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
void reset(T* p)
{
    delete ptr;
    ptr = p;
}
\end{minted}

Оператор присваивания и конструктор копирования у \mintinline{c++}{unique_ptr} явно запрещены:
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
unique_ptr(unique_ptr& other) = delete;
unique_ptr& operator=(unique_ptr& other) = delete;
\end{minted}
При попытке скопировать или присвоить \mintinline{c++}{unique_ptr} выдаётся ошибка на этапе компиляции.

\mintinline{c++}{unique_ptr} имеет move-оператор присваивания и move-конструктор, которые зануляют указатель, стоящий справо:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
unique_ptr& operator=(unique_ptr&& other) noexcept
{
    reset(other.release());
    return *this;
}

unique_ptr(unique_ptr&& other) noexcept
    : ptr(other.release())
{}
\end{minted}

\subsubsection{Неявные приведения}
\label{unique_ptr_implicit_conversions}

Обычные указатели можно неявно приводить. Например если \mintinline{c++}{B} является некоторым классом, а \mintinline{c++}{D} является производным от него, то разрешено неявное приведение \mintinline{c++}{D*} в \mintinline{c++}{B*}. \mintinline{c++}{unique_ptr} поддерживает аналогичное приведение. \mintinline{c++}{unique_ptr} использует SFINAE-проверку, чтобы разрешить приведение \mintinline{c++}{unique_ptr<D>} в \mintinline{c++}{unique_ptr<B>} тогда и только тогда, когда разрешено приведение \mintinline{c++}{D*} в \mintinline{c++}{B*}.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template <typename T>
struct unique_ptr
{
    template <typename U,
              typename = typename std::enable_if_t<is_convertible_v<U*, T*>>>
    unique_ptr(unique_ptr<U>&& other);
};
\end{minted}

\subsubsection{Настраиваемый deleter}

В некоторых случаях для освобождения памяти необходимо использовать не \mintinline{c++}{delete}, а другие операции. Например если память была выделена с помощью функции \mintinline{c++}{malloc} её следует освобождать функцией \mintinline{c++}{free}, а если с помощью оператора \mintinline{c++}{new[]} для массивов, то оператором \mintinline{c++}{delete[]} для массивов. Существуют и другие способы освобождения ресурсов, поэтому в некоторых случаях может потребоваться исполнение какого-то произвольного кода в деструкторе \mintinline{c++}{unique_ptr}. \mintinline{c++}{unique_ptr} поддерживает такое использование.

Для того, чтобы указать, что именно делать в деструкторе, \mintinline{c++}{std::unique_ptr} получает специальный объект называемый {\bf deleter}. Сильно упрощенно \mintinline{c++}{unique_ptr} с deleter'ом можно записать следующим образом:
\begin{listing}
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template <typename T, typename D = default_delete<T>>
struct unique_ptr
{
    using pointer = typename D::pointer;

    unique_ptr(pointer);
    unique_ptr(pointer, D);

    ~unique_ptr()
    {
        deleter(ptr);
    }

private:
    pointer ptr;
    D deleter;
};
\end{minted}
\caption{Упрощенная реализация \mintinline{c++}{unique_ptr} с deleter'ом}
\label{listing:unique_ptr_with_deleter}
\end{listing}

Таким образом видно, что на самом деле \mintinline{c++}{unique_ptr} хранит в качестве указателя не обязательно \mintinline{c++}{T*}, а любой объект типа \mintinline{c++}{D::pointer}. По этой причине некоторые члены \mintinline{c++}{unique_ptr} не помечены \mintinline{c++}{noexcept}, например, \mintinline{c++}{operator*}.

По умолчанию в качестве deleter используется класс \mintinline{c++}{default_delete}, который вызывает оператор \mintinline{c++}{delete} на переданном указателе.

В реальности \mintinline{c++}{std::unique_ptr} устроен гораздо сложнее, чем показано на листинге \ref{listing:unique_ptr_with_deleter}. Это обусловлено следующими причинами:

\begin{itemize}
    \item Шаблонный параметр \mintinline{c++}{D} может быть не самим типом deleter'а, а ссылой на deleter. Поэтому при обращении \mintinline{c++}{D::pointer}, предварительно следует снять ссылку с \mintinline{c++}{D}.
    \item Deleter не обязан содержать typedef \mintinline{c++}{pointer}. Если он отсутствует, \mintinline{c++}{unique_ptr} должен использовать \mintinline{c++}{T*} вместо него. Это требует от \mintinline{c++}{unique_ptr} использования SFINAE-проверки.
    \item Часто deleter является пустым объектом. Чтобы не увеличивать размер \mintinline{c++}{unique_ptr} при реализации используется empty-base оптимизация.
\end{itemize}

При перемещении \mintinline{c++}{unique_ptr}, перемещается и его deleter. Отдельно следует рассмотреть, что происходит с deleter'ами при неявных приведениях \mintinline{c++}{unique_ptr} рассмотренных в разделе \ref{unique_ptr_implicit_conversions}. Важным является тот факт, что результирующий \mintinline{c++}{unique_ptr} и исходный могут иметь deleter'ы разных типов. При использовании deleter'ов, конверсия из \mintinline{c++}{unique_ptr<T1, D1>} разрешена в \mintinline{c++}{unique_ptr<T2, D2>} если выполнено одно из двух условий:
\begin{itemize}
    \item \mintinline{c++}{D2} является ссылкой и \mintinline{c++}{D1} совпадает с \mintinline{c++}{D2}.
    \item \mintinline{c++}{D2} не является ссылкой и \mintinline{c++}{D1} приводим в \mintinline{c++}{D2}.
\end{itemize}

\subsubsection{unique\_ptr для массивов}

\mintinline{c++}{unique_ptr} имеет отдельную специализацию для массивов:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template <typename T, typename D = default_delete<T>>
struct unique_ptr;

template <typename E, typename D>
struct unique_ptr<E[], D>
{
    E& operator[](size_t index) const;
};
\end{minted}

\mintinline{c++}{unique_ptr} для массивов отличается от обычного \mintinline{c++}{unique_ptr} следующими свойствами:
\begin{itemize}
    \item \mintinline{c++}{unique_ptr} для массивов имеет \mintinline{c++}{operator[]}. Обычный \mintinline{c++}{unique_ptr} не имеет \mintinline{c++}{operator[]}.
    \item \mintinline{c++}{unique_ptr} для массивов хранит внутри себя \mintinline{c++}{E*}, а не \mintinline{c++}{T*}.
    \item \mintinline{c++}{unique_ptr} для массивов использует более жесткие правила для неявных преобразований. Обычные указатели можно приводить по иерархии наследования. Но указатель на массив элементов типа \mintinline{c++}{D} не приводим в указатель на массив элементов типа \mintinline{c++}{B}, даже если \mintinline{c++}{D} --- это тип производный от \mintinline{c++}{B}, поскольку \mintinline{c++}{B} и \mintinline{c++}{D} могут иметь разных размер, а в массиве элементы расположены подряд.
\end{itemize}

Как и \mintinline{c++}{unique_ptr}, \mintinline{c++}{default_delete} имеет специализацию для массивов, которая делает \mintinline{c++}{delete[]} вместо обычного \mintinline{c++}{delete}.

\subsection{Владение}
Ответственность за удаление объекта называется владением. Например, unique\_ptr ответственен за удаление объекта на который он ссылается, соответственно говорят, что unique\_ptr владеет объектом, на который он ссылается. Про функцию \mintinline{c++}{reset(p)} говорят, что она передает владение объектом unique\_ptr'у, а функция \mintinline{c++}{release()}, наоборот, забирает владение объектом у unique\_ptr'а.

Термин владение применяется не только к умным указателям, например можно сказать, что std::vector владеет памятью выделенной под свои элементы (обязан её освободить), а также владеет своими элементами (обязан вызывать им деструктор).

В некоторых случаях объект может иметь несколько владельцев. Это называется разделяемым владением и работает следующим образом: пока существует хотя бы один владелец объект продолжает жить, когда пропадает последний владелец --- объект удаляется. Для умных указателей существует два способа реализации разделяемого владения: подсчет ссылок и провязка всех владельцев в двусвязный список. Оба подхода имеют свои преимущества и недостатки. Подсчет ссылок применяется во включенном в стандартную библиотеку указателе std::shared\_ptr. Указатель использующий провязку владельцев в двусвязный список в стандартной библиотеке отсутствует, но часто называется linked\_ptr.
