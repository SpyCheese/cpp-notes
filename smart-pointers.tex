\section{Умные указатели}

Рассмотрим следующий код:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
container* create_container()
{
    container* c = new container();
    fill(*c);
    return c;
}
\end{minted}

В приведенном коде, при возникновении исключения в функции fill, это исключение пролетит наружу функции create\_container. Однако выделенный с помощью new контейнер c не будет освобожден. Возможным способом исправления этой ошибки является использование try…catch блока:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
container* create_container()
{
    container* c = new container();
    try
    {
        fill(*c);
    }
    catch(...)
    {
        delete c;
        throw;
    }
    return c;
}
\end{minted}

Такой способ применим если лишь к простейшим функциям. При начилии нескольких объектов, которые требуется удалить или в присутствии сложного control-flow такое использование try...catch становится непрактичным.

Для решения этой проблемы в C++11 появились классы умных указателей (\mintinline{c++}{std::unique_ptr}, \mintinline{c++}{std::shared_ptr} и \mintinline{c++}{std::weak_ptr}). Эти классы являются RAII-обертками над обычными указателями, которые в своём деструкторе делают \mintinline{c++}{delete} тому объекту, на который они ссылаются. При использовании \mintinline{c++}{std::unique_ptr} приведенный выше (корректный) код может быть записан следующим образом:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
std::unique_ptr<container> create_container()
{
    std::unique_ptr<container> c(new container());
    fill(*c);
    return c;
}
\end{minted}

\subsection{unique\_ptr}
Самым простым умным указателем является \mintinline{c++}{std::unique_ptr}.
Внутри себя \mintinline{c++}{std::unique_ptr} хранит один указатель \mintinline{c++}{T* ptr} и делает ему \mintinline{c++}{delete} в дескрукторе.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template<class T>
class unique_ptr
{
private:
    T* ptr;
public:
    unique_ptr()
        : ptr(nullptr)
    {}

    unique_ptr(T* ptr)
        : ptr(ptr)
    {}

    ~unique_ptr()
    {
        delete ptr;
    }
    ...
}
\end{minted}

\mintinline{c++}{std::unique_ptr} имеет операторы \mintinline{c++}{*} и \mintinline{c++}{->}, поэтому им можно пользоваться как обычным указателем:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T& operator*() const { return *ptr; }
T* operator->() const noexcept { return ptr; }
\end{minted}

\mintinline{c++}{std::unique_ptr} имеет следующие функции:

\mintinline{c++}{get()} --- возвращает ptr, хранящийся внутри. \mintinline{c++}{get()} может использоваться если необходимо передать в некоторую функцию сырой указатель на объект, а имеется \mintinline{c++}{unique_ptr} на него.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T* get() const { return ptr; }
\end{minted}

\mintinline{c++}{release()} --- зануляет ptr, хранящийся внутри, а старое значение возвращает наружу. \mintinline{c++}{release()} может использоваться если необходимо передать в некоторую функцию сырой указатель на объект и известно, что эта функция самостоятельно удалит переданный объект.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T* release()
{
    T* tmp = ptr;
    ptr = nullptr;
    return tmp;
}
\end{minted}

\mintinline{c++}{reset(p)} - заменяет ptr, хранящийся внутри, на p, и делает \mintinline{c++}{delete} старому ptr.
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
void reset(T* p)
{
    delete ptr;
    ptr = p;
}
\end{minted}

Оператор присваивания и конструктор копирования у \mintinline{c++}{unique_ptr} явно запрещены:
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
unique_ptr(unique_ptr& other) = delete;
unique_ptr& operator=(unique_ptr& other) = delete;
\end{minted}
При попытке скопировать или присвоить \mintinline{c++}{unique_ptr} выдаётся ошибка на этапе компиляции.

\mintinline{c++}{unique_ptr} имеет move-оператор присваивания и move-конструктор, которые зануляют указатель, стоящий справо:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
unique_ptr& operator=(unique_ptr&& other) noexcept
{
    reset(other.release());
    return *this;
}

unique_ptr(unique_ptr&& other) noexcept
    : ptr(other.release())
{}
\end{minted}

\subsubsection{Настраиваемый deleter}

В некоторых случаях для освобождения памяти необходимо использовать не \mintinline{c++}{delete}, а другие операции. Например если память была выделена с помощью функции \mintinline{c++}{malloc} её следует освобождать функцией \mintinline{c++}{free}, а если с помощью оператора \mintinline{c++}{new[]} для массивов, то оператором \mintinline{c++}{delete[]} для массивов. Существуют и другие способы освобождения ресурсов, поэтому в некоторых случаях может потребоваться исполнение какого-то произвольного кода в деструкторе \mintinline{c++}{unique_ptr}. \mintinline{c++}{unique_ptr} поддерживает такое использование.

Для того, чтобы указать, что именно делать в деструкторе, \mintinline{c++}{std::unique_ptr} получает специальный объект называемый {\bf deleter}. Сильно упрощенно \mintinline{c++}{unique_ptr} с deleter'ом можно записать следующим образом:
\begin{listing}
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template <typename T, typename D = default_delete<T>>
struct unique_ptr
{
    using pointer = typename D::pointer;

    unique_ptr(pointer);
    unique_ptr(pointer, D);

    ~unique_ptr()
    {
        deleter(ptr);
    }

private:
    pointer ptr;
    D deleter;
};
\end{minted}
\caption{Упрощенная реализация \mintinline{c++}{unique_ptr} с deleter'ом}
\label{listing:unique_ptr_with_deleter}
\end{listing}

Таким образом видно, что на самом деле \mintinline{c++}{unique_ptr} хранит в качестве указателя не обязательно \mintinline{c++}{T*}, а любой объект типа \mintinline{c++}{D::pointer}. По этой причине некоторые члены \mintinline{c++}{unique_ptr} не помечены \mintinline{c++}{noexcept}, например, \mintinline{c++}{operator*}.

По умолчанию в качестве deleter используется класс \mintinline{c++}{default_delete}, который вызывает оператор \mintinline{c++}{delete} на переданном указателе.

В реальности \mintinline{c++}{std::unique_ptr} устроен гораздо сложнее, чем показано на листинге \ref{listing:unique_ptr_with_deleter}. Это обусловлено следующими причинами:

\begin{itemize}
    \item Шаблонный параметр \mintinline{c++}{D} может быть не типом deleter'а, а ссылой на deleter. Поэтому при обращении \mintinline{c++}{D::pointer}, предварительно следует снять ссылку с \mintinline{c++}{D}.
    \item Deleter не обязан содержать typedef \mintinline{c++}{pointer}. Если он отсутствует, \mintinline{c++}{unique_ptr} должен использовать \mintinline{c++}{T*} вместо него. Это требует от \mintinline{c++}{unique_ptr} использования SFINAE-проверки.
    \item Часто deleter является пустым объектом. Чтобы не увеличивать размер \mintinline{c++}{unique_ptr} при реализации используется empty-base оптимизация.
\end{itemize}

\subsection{Владение}
Ответственность за удаление объекта называется владением. Например, unique\_ptr ответственен за удаление объекта на который он ссылается, соответственно говорят, что unique\_ptr владеет объектом, на который он ссылается. Про функцию \mintinline{c++}{reset(p)} говорят, что она передает владение объектом unique\_ptr'у, а функция \mintinline{c++}{release()}, наоборот, забирает владение объектом у unique\_ptr'а.

Термин владение применяется не только к умным указателям, например можно сказать, что std::vector владеет памятью выделенной под свои элементы (обязан её освободить), а также владеет своими элементами (обязан вызывать им деструктор).

В некоторых случаях объект может иметь несколько владельцев. Это называется разделяемым владением и работает следующим образом: пока существует хотя бы один владелец объект продолжает жить, когда пропадает последний владелец --- объект удаляется. Для умных указателей существует два способа реализации разделяемого владения: подсчет ссылок и провязка всех владельцев в двусвязный список. Оба подхода имеют свои преимущества и недостатки. Подсчет ссылок применяется во включенном в стандартную библиотеку указателе std::shared\_ptr. Указатель использующий провязку владельцев в двусвязный список в стандартной библиотеке отсутствует, но часто называется linked\_ptr.
